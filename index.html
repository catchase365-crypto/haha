<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>高清哈哈镜泡泡</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none; /* 阻止浏览器默认滚动 */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        #error-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5555;
            text-align: center;
            display: none;
            width: 80%;
        }
    </style>
</head>
<body>

    <canvas id="glcanvas"></canvas>
    <div id="ui">上下滑动调节畸变 | 左右滑动旋转</div>
    <div id="error-msg"></div>

    <video id="webcam" playsinline style="display:none;"></video>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_uv = a_position; // 传递 -1.0 到 1.0 的坐标
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float; // 强制使用高精度浮点，保证“无损”清晰度

        uniform vec2 u_resolution; // 屏幕分辨率
        uniform vec2 u_video_res;  // 摄像头源分辨率
        uniform float u_radius;    // 泡泡半径
        uniform float u_distortion; // 畸变强度
        uniform float u_rotation;   // 旋转角度
        
        uniform sampler2D u_camera; // 摄像头纹理

        varying vec2 v_uv;

        // 旋转矩阵
        mat2 rotate2d(float angle){
            return mat2(cos(angle), -sin(angle),
                        sin(angle), cos(angle));
        }

        void main() {
            // 1. 屏幕坐标修正：将画布坐标修正为正方形比例，原点在中心
            vec2 uv = v_uv;
            float screenAspect = u_resolution.x / u_resolution.y;
            
            // 修正比例，使圆形不被拉伸
            if (screenAspect > 1.0) {
                uv.x *= screenAspect;
            } else {
                uv.y /= screenAspect;
            }

            // 2. 圆形裁剪与 3D 模拟
            float r = length(uv);
            if (r > u_radius) {
                discard; // 圆圈外丢弃
            }

            // 计算球体表面的 Z 深度（用于简单的光照和折射模拟）
            float z = sqrt(1.0 - (r/u_radius)*(r/u_radius));
            vec3 normal = vec3(uv.x/u_radius, uv.y/u_radius, z);

            // 3. 哈哈镜畸变算法 (Spherize / Fisheye)
            // 根据距离中心的远近，非线性地偏移纹理坐标
            // u_distortion > 0 放大(大鼻子), < 0 缩小(大脸)
            float effect = 1.0 + z * u_distortion;
            vec2 distortedUV = uv / effect;

            // 应用旋转
            distortedUV = rotate2d(u_rotation) * distortedUV;


            // 4. 纹理坐标映射 (Texture Mapping - Cover Mode)
            // 关键步骤：将畸变后的坐标映射回摄像头纹理坐标 [0, 1]
            // 需要保持“Cover”模式（填满圆圈且不拉伸）
            
            float videoAspect = u_video_res.x / u_video_res.y;
            
            // 将 [-1, 1] 映射回 [0, 1]
            vec2 texUV = distortedUV * 0.5 + 0.5;
            
            // 修正摄像头画面比例 (类似于 CSS object-fit: cover)
            // 我们希望画面中心对齐，且填满泡泡
            // 这里我们假设泡泡是正方形视口
            vec2 scale = vec2(1.0);
            if (videoAspect > 1.0) {
                // 视频比正方形宽，裁剪左右
                scale.x = 1.0 / videoAspect; 
                texUV.x = (texUV.x - 0.5) * scale.x + 0.5;
            } else {
                // 视频比正方形高（竖屏手机通常如此），裁剪上下
                scale.y = videoAspect;
                texUV.y = (texUV.y - 0.5) * scale.y + 0.5;
            }

            // 镜像翻转 (前置摄像头习惯)
            texUV.x = 1.0 - texUV.x;

            // 5. 采样颜色
            vec3 color = texture2D(u_camera, texUV).rgb;

            // 6. 添加玻璃质感 (边缘光与反射)
            // 菲涅尔效应：边缘变亮
            float fresnel = pow(1.0 - z, 3.0);
            // 简单的边缘高光
            color += vec3(0.2, 0.3, 0.4) * fresnel * 0.8;
            // 边缘平滑 (Anti-aliasing)
            float alpha = smoothstep(u_radius, u_radius - 0.02, r);

            gl_FragColor = vec4(color, alpha);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl', { alpha: true });
        const video = document.getElementById('webcam');
        const errorMsg = document.getElementById('error-msg');

        if (!gl) alert("不支持 WebGL");

        // --- 1. 摄像头处理 ---
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: {
                        facingMode: 'user', // 前置
                        width: { ideal: 1280 }, // 请求高清分辨率
                        height: { ideal: 720 }
                    }
                });
                video.srcObject = stream;
                await video.play();
                initWebGL();
            } catch (err) {
                console.error(err);
                errorMsg.style.display = 'block';
                errorMsg.innerText = "无法打开摄像头: " + err.message + "\n请确保在 HTTPS 环境或本地 localhost 打开，并授权权限。";
            }
        }

        // --- 2. WebGL 初始化 ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        let program;
        let texture;
        let u_resolution, u_video_res, u_radius, u_distortion, u_rotation;
        
        // 交互变量
        let distortionLevel = 0.5; // 默认轻微放大
        let rotationAngle = 0.0;
        let targetRadius = 0.85;

        function initWebGL() {
            // 编译 Shader
            const vs = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text);
            program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            gl.useProgram(program);

            // 顶点数据 (全屏四边形)
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,  1, -1, -1,  1,
                -1,  1,  1, -1,  1,  1
            ]), gl.STATIC_DRAW);
            
            const a_position = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

            // 获取 Uniforms
            u_resolution = gl.getUniformLocation(program, "u_resolution");
            u_video_res = gl.getUniformLocation(program, "u_video_res");
            u_radius = gl.getUniformLocation(program, "u_radius");
            u_distortion = gl.getUniformLocation(program, "u_distortion");
            u_rotation = gl.getUniformLocation(program, "u_rotation");

            // 创建纹理
            texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // 设置纹理参数：必须是 CLAMP_TO_EDGE 和 LINEAR 以适应非 POT 视频尺寸
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            resize();
            render();
        }

        // --- 3. 渲染循环 ---
        function render() {
            if (video.readyState >= video.HAVE_CURRENT_DATA) {
                // 每帧将视频画面上传到 GPU
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
                
                gl.uniform2f(u_resolution, canvas.width, canvas.height);
                gl.uniform2f(u_video_res, video.videoWidth, video.videoHeight);
                gl.uniform1f(u_radius, targetRadius);
                gl.uniform1f(u_distortion, distortionLevel);
                gl.uniform1f(u_rotation, rotationAngle);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            requestAnimationFrame(render);
        }

        // --- 4. 尺寸与交互 ---
        function resize() {
            // 使用 devicePixelRatio 保证 Retina 屏幕清晰度 (无损关键)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);

        // 触控交互
        let startY = 0;
        let startX = 0;
        
        document.addEventListener('touchstart', (e) => {
            startY = e.touches[0].clientY;
            startX = e.touches[0].clientX;
        }, {passive: false});

        document.addEventListener('touchmove', (e) => {
            e.preventDefault(); // 阻止滚动
            const dy = e.touches[0].clientY - startY;
            const dx = e.touches[0].clientX - startX;
            
            // 上下改变畸变强度 (-0.5 到 1.5)
            // 向上滑(负数) -> 变大， 向下滑 -> 变小
            distortionLevel -= dy * 0.005; 
            // 限制范围
            if (distortionLevel > 2.0) distortionLevel = 2.0;
            if (distortionLevel < -0.5) distortionLevel = -0.5;

            // 左右改变旋转
            rotationAngle += dx * 0.005;

            startY = e.touches[0].clientY;
            startX = e.touches[0].clientX;
        }, {passive: false});

        // 启动
        setupCamera();

    </script>
</body>
</html>
